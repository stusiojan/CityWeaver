import Foundation
import Terrain

/// Exports road networks and terrain to Wavefront OBJ format for use in 3D software like Blender
public struct OBJExporter: Sendable {
    
    /// Configuration for OBJ export
    public struct ExportOptions: Sendable {
        /// Width of road segments in meters
        public let roadWidth: Double
        /// Height of road surface above terrain
        public let roadElevation: Double
        /// Whether to include terrain mesh
        public let includeTerrain: Bool
        /// Terrain downsampling factor (1 = full resolution)
        public let terrainDownsample: Int
        /// Vertical scale multiplier for terrain
        public let terrainVerticalScale: Double
        
        public init(
            roadWidth: Double = 4.0,
            roadElevation: Double = 0.1,
            includeTerrain: Bool = true,
            terrainDownsample: Int = 1,
            terrainVerticalScale: Double = 1.0
        ) {
            self.roadWidth = roadWidth
            self.roadElevation = roadElevation
            self.includeTerrain = includeTerrain
            self.terrainDownsample = terrainDownsample
            self.terrainVerticalScale = terrainVerticalScale
        }
    }
    
    public init() {}
    
    /// Export road network and optional terrain to OBJ format
    /// - Parameters:
    ///   - segments: Array of road segments
    ///   - terrainMap: Optional terrain map for elevation data
    ///   - options: Export configuration options
    /// - Returns: Tuple of OBJ file content and MTL file content
    @MainActor
    public func export(
        segments: [RoadSegment],
        terrainMap: Terrain.TerrainMap?,
        options: ExportOptions = ExportOptions()
    ) -> (obj: String, mtl: String) {
        var objContent = """
        # Wavefront OBJ file generated by CityWeaver
        # Road network with \(segments.count) segments
        
        mtllib roads.mtl
        
        """
        
        var mtlContent = """
        # Material file generated by CityWeaver
        
        """
        
        var vertexIndex = 1
        
        // Generate road materials and geometry
        mtlContent += generateRoadMaterial()
        
        for (index, segment) in segments.enumerated() {
            let (vertices, faces) = generateRoadGeometry(
                segment: segment,
                terrainMap: terrainMap,
                options: options
            )
            
            objContent += "\n# Road segment \(index + 1)\n"
            objContent += "o Road_\(index + 1)\n"
            objContent += "usemtl road_\(segment.attributes.roadType)\n"
            
            // Add vertices
            for vertex in vertices {
                objContent += String(format: "v %.6f %.6f %.6f\n", vertex.x, vertex.y, vertex.z)
            }
            
            // Add faces (adjust indices by current vertex count)
            for face in faces {
                let adjustedFace = face.map { $0 + vertexIndex - 1 }
                objContent += "f \(adjustedFace.map { String($0) }.joined(separator: " "))\n"
            }
            
            vertexIndex += vertices.count
        }
        
        // Generate terrain if requested
        if options.includeTerrain, let terrainMap = terrainMap {
            mtlContent += generateTerrainMaterial()
            let (terrainObj, terrainVertices) = generateTerrainGeometry(
                terrainMap: terrainMap,
                options: options,
                startIndex: vertexIndex
            )
            objContent += terrainObj
            vertexIndex += terrainVertices
        }
        
        return (obj: objContent, mtl: mtlContent)
    }
    
    /// Generate 3D geometry for a road segment
    @MainActor private func generateRoadGeometry(
        segment: RoadSegment,
        terrainMap: Terrain.TerrainMap?,
        options: ExportOptions
    ) -> (vertices: [(x: Double, y: Double, z: Double)], faces: [[Int]]) {
        let attrs = segment.attributes
        let halfWidth = options.roadWidth / 2.0
        
        // Calculate road endpoints
        let startX = Double(attrs.startPoint.x)
        let startY = Double(attrs.startPoint.y)
        let endX = startX + cos(attrs.angle) * attrs.length
        let endY = startY + sin(attrs.angle) * attrs.length
        
        // Calculate perpendicular offset for road width
        let perpAngle = attrs.angle + .pi / 2
        let offsetX = cos(perpAngle) * halfWidth
        let offsetY = sin(perpAngle) * halfWidth
        
        // Get elevation from terrain or use default
        let startZ = getElevation(x: startX, y: startY, terrainMap: terrainMap) + options.roadElevation
        let endZ = getElevation(x: endX, y: endY, terrainMap: terrainMap) + options.roadElevation
        
        // Create road vertices (rectangular prism)
        let vertices: [(x: Double, y: Double, z: Double)] = [
            // Top surface
            (startX - offsetX, startZ, startY - offsetY),  // 1
            (startX + offsetX, startZ, startY + offsetY),  // 2
            (endX + offsetX, endZ, endY + offsetY),        // 3
            (endX - offsetX, endZ, endY - offsetY),        // 4
            // Bottom surface (slightly below)
            (startX - offsetX, startZ - 0.05, startY - offsetY),  // 5
            (startX + offsetX, startZ - 0.05, startY + offsetY),  // 6
            (endX + offsetX, endZ - 0.05, endY + offsetY),        // 7
            (endX - offsetX, endZ - 0.05, endY - offsetY)         // 8
        ]
        
        // Define faces (counter-clockwise winding)
        let faces: [[Int]] = [
            [1, 2, 3, 4],  // Top
            [5, 8, 7, 6],  // Bottom
            [1, 4, 8, 5],  // Side 1
            [2, 1, 5, 6],  // Side 2
            [3, 2, 6, 7],  // Side 3
            [4, 3, 7, 8]   // Side 4
        ]
        
        return (vertices: vertices, faces: faces)
    }
    
    /// Generate terrain mesh geometry
    @MainActor
    private func generateTerrainGeometry(
        terrainMap: Terrain.TerrainMap,
        options: ExportOptions,
        startIndex: Int
    ) -> (obj: String, vertexCount: Int) {
        var objContent = "\n# Terrain\no Terrain\nusemtl terrain\n"
        
        let dims = terrainMap.dimensions
        let step = options.terrainDownsample
        
        var vertices: [(x: Double, y: Double, z: Double)] = []
        
        // Generate vertices
        for y in stride(from: 0, to: dims.rows, by: step) {
            for x in stride(from: 0, to: dims.cols, by: step) {
                if let node = terrainMap.getNode(at: x, y: y) {
                    let vertex = (
                        x: node.coordinates.x,
                        y: node.coordinates.z * options.terrainVerticalScale,
                        z: node.coordinates.y
                    )
                    vertices.append(vertex)
                    objContent += String(format: "v %.6f %.6f %.6f\n", vertex.x, vertex.y, vertex.z)
                }
            }
        }
        
        // Generate faces (triangles for terrain)
        let cols = (dims.cols + step - 1) / step
        for y in 0..<((dims.rows + step - 1) / step - 1) {
            for x in 0..<(cols - 1) {
                let i1 = startIndex + y * cols + x
                let i2 = i1 + 1
                let i3 = i1 + cols
                let i4 = i3 + 1
                
                // Two triangles per quad
                objContent += "f \(i1) \(i2) \(i4)\n"
                objContent += "f \(i1) \(i4) \(i3)\n"
            }
        }
        
        return (obj: objContent, vertexCount: vertices.count)
    }
    
    /// Generate material definitions for roads
    private func generateRoadMaterial() -> String {
        return """
        # Road materials
        newmtl road_main
        Ka 0.2 0.2 0.2
        Kd 0.3 0.3 0.3
        Ks 0.1 0.1 0.1
        Ns 10.0
        
        newmtl road_highway
        Ka 0.15 0.15 0.15
        Kd 0.25 0.25 0.25
        Ks 0.1 0.1 0.1
        Ns 10.0
        
        newmtl road_residential
        Ka 0.25 0.25 0.25
        Kd 0.35 0.35 0.35
        Ks 0.1 0.1 0.1
        Ns 10.0
        
        newmtl road_street
        Ka 0.2 0.2 0.2
        Kd 0.32 0.32 0.32
        Ks 0.1 0.1 0.1
        Ns 10.0
        
        """
    }
    
    /// Generate material definition for terrain
    private func generateTerrainMaterial() -> String {
        return """
        # Terrain material
        newmtl terrain
        Ka 0.4 0.35 0.3
        Kd 0.6 0.5 0.4
        Ks 0.05 0.05 0.05
        Ns 5.0
        
        """
    }
    
    /// Get elevation from terrain map or return default
    @MainActor private func getElevation(x: Double, y: Double, terrainMap: Terrain.TerrainMap?) -> Double {
        guard let terrainMap = terrainMap else { return 0.0 }
        let node = terrainMap.getNode(at: (x: x, y: y))
        return node?.coordinates.z ?? 0.0
    }
    
    /// Save OBJ and MTL files to disk
    /// - Parameters:
    ///   - obj: OBJ file content
    ///   - mtl: MTL file content
    ///   - directory: Directory to save files
    ///   - basename: Base name for files (without extension)
    public func saveToFiles(
        obj: String,
        mtl: String,
        directory: URL,
        basename: String = "roads"
    ) throws {
        let objURL = directory.appending(path: "\(basename).obj")
        let mtlURL = directory.appending(path: "\(basename).mtl")
        
        try obj.write(to: objURL, atomically: true, encoding: .utf8)
        try mtl.write(to: mtlURL, atomically: true, encoding: .utf8)
    }
}

