# source: https://nothings.org/gamedev/l_systems.html

# ALGORIHTM

initialize priority queue Q with a single entry:
     r(0,ra,qa)

initialize segment list S to empty

until Q is empty
    pop smallest r(t,ra,qa) from Q
        compute (nqa, state) = localConstraints(qa)
        if (state == SUCCEED) {
            add segment(ra) to S
            addZeroToThreeRoadsUsingGlobalGoals(Q, t+1, qa,ra)

# PARAMS

Q - priority queue: This is a "to-do" list of potential road segments waiting to be processed. It replaces the complex, iterative string rewriting of the L-system. Items are prioritized by their timestamp 't'

S - segment list: This is the final output list of successfully placed road segments. Together, the segments in 'S' form the city's street map.

r(t, ra, qa) - road query: An item in the priority queue 'Q'. It's a proposal to create a new road segment.

t - time: An integer representing the priority. The algorithm always processes the query with the lowest 't' first. This elegantly handles the delays (pdel) that were cumbersome to manage in the L-system.

ra - road attributes: A data structure containing the geometric properties of the proposed road segment. This would include its starting point, direction (angle), length, and type (e.g., highway, residential street).

qa - query attributes: Data associated with the request to build the road. This is passed to localConstraints for evaluation. It's largely the same as 'ra' but represents the "proposal" rather than the final geometry.

segment(ra): A confirmed, immutable road segment that has passed all checks. Its geometry is defined by the attributes in $ra$. These are the final building blocks of the city grid.

# FUNCTIONS

localConstraints(qa): This function acts as a validation step. It takes the attributes of a proposed road ('qa') and checks if it's "legal" according to immediate, local rules. Its primary job is to prevent physical impossibilities and maintain local order. For a city, it would typically:

	1. Check for intersections with existing road segments in 'S'.

	2. Check if the new road comes too close to another parallel road.

	3. Ensure the road doesn't go outside the defined city boundaries or into a forbidden area (like a body of water).

	4. Potentially adjust the road proposal (e.g., shortening it to connect cleanly to an existing intersection).
	
	It returns the final state of the proposal: SUCCEED if the road is valid (and potentially adjusted in nqa), or FAILED if it violates a rule.

addZeroToThreeRoadsUsingGlobalGoals(Q, t+1, nqa, ra): This function acts as the expansion and branching step. After a road segment is successfully added to the map, this function generates the next set of road proposals based on higher-level rules, or "global goals," that define the city's overall character. It is responsible for:

	1. Determining how many new roads should branch off from the end of the newly created segment (from zero to three, as per the original paper: one continuing straight and two branching off).

	2. Calculating the attributes ('ra', 'qa') for these new proposals based on global patterns (e.g., a strict grid, a radial pattern originating from a city center, or an organic, winding pattern).

	3. Assigning a delay to each new proposal, which is then added to the current time 't+1' to determine its priority in the queue 'Q'. This controls the pace and order of the city's growth.
	
	Essentially, this function consults the master plan for the city to decide what to build next.
